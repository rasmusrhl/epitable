---
title: "`epitable` Create HTML Tables in the Style Used in Epidemiological Papers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{epitable_vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(epitable)
```

# Introduction
`epitable` produces tables in the style of epidemiological papers. The output in this vignette is 

# `freq_by`
The `freq_by`-function creates a frequency and percentage table commonly used in
epidemiological papers. It is a wrapper for the [htmlTables-package](https://cran.r-project.org/package=htmlTable).

```{r}
head(example_data)
```

The `by_group` variable must be of class factor, to ensure correct order. The argument `min_cell_count` sets the minimum number of observations in a cell. It is inteded to preserve anonymity in case of sensitive data. When the cell count is <= `min_cell_count`, the number is deleted from that cell. 

It is possible to change the font using the `font_css` argument, but the font needs to be web-friendly. Below the font is set to "font-family: Times":
```{r}
freq_by(dataset = example_data, var_vector = c("color", "clarity"), by_group = "cut", font_css = "font-family: Times" )
```


# `model_to_html`

The `model_to_html`-function can print simple models to HTML, also printing the reference levels of the categorical covariates. It does not support variables of class `ordered`. 

## Printing a `coxph`-model

```{r, results='asis'}
 df         <- survival::lung
 df$age_bin <- Hmisc::cut2( df$age, g = 5)
 df$ph_bin  <- Hmisc::cut2( df$ph.karno, g = 5)
 df$sex     <- factor( df$sex)
 model1      <- survival::coxph( survival::Surv( time = time, event = status==1) ~ age_bin + factor(sex) + ph_bin + wt.loss, data = df )
 model_to_html(model1, exponentiate = TRUE )
```


## Printing a logistic regression

```{r}
 diamonds <- ggplot2::diamonds
 diamonds$color <- factor(diamonds$color, ordered = FALSE)
 diamonds$clarity <- factor(diamonds$clarity, ordered = FALSE)
 glm_logistic <- glm( cut=="Ideal" ~  color + clarity + x , data = diamonds, family = "binomial")
 model_to_html(glm_logistic, exponentiate = TRUE)
```


## Printing a general linear regression

```{r}
 glm_linear <- glm( Sepal.Width ~  Petal.Width + Sepal.Length + Petal.Length +  Species, data = iris)
 model_to_html(glm_linear) 
```


## Printing a two lists of models

The example below tages two lists of models. One list of univariate models, and another list of multivariate models. The multivariate models include incrementally more variables, so that the final multivariate model include all the variables used in the univariate models.

```{r}
# univariate models in a list:
c("Age" , "Embarked" , "Sex" , "Fare" , "Pclass") %>%
  paste0( "Survived ~ ", . ) %>%
  purrr::map( ~ glm( as.formula(.), data = titanic, family = "binomial" )) -> univar_list

# multivariate models in a list:
glm_logistic_1 <- glm( Survived ~  Age + Embarked, data = titanic, family = "binomial")
glm_logistic_2 <- glm( Survived ~  Age + Embarked + Sex + Fare, data = titanic, family = "binomial")
glm_logistic_3 <- glm( Survived ~  Age + Embarked + Sex + Fare + Pclass, data = titanic, family = "binomial")
multi_model_list <- list(glm_logistic_1, glm_logistic_2,  glm_logistic_3 )

model_to_html(univariate_models_list = univar_list,
              multivariate_models_list = multi_model_list,
              exponentiate = TRUE ) 

```









To do in a possible future:

* Add totals to each of the `by_group`s
* option to specify better names to the rgroup, not just the variable names.
* include other summary statistics








